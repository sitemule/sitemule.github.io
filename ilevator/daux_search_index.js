load_search_index({"pages":[{"title":"ILEvator","text":"","tags":"","url":"index.html"},{"title":"Installation","text":"ILEvator can be installed in various ways with more or less effort depending on the choice. #From Source The prerequisites for building ILEvator from source are at least IBM i OS release 7.3, access to the IFS of your IBM i server, ILE C and RPG compiler and gmake. gmake can be installed via yum. If all prerequisites are met you can either download or clone the Git repository to your IBM i server. You start building the project just be executing gmake. By default the library ILEVATOR will be created and all objects will be placed in that library. #Build Options You can change the target library by passing the parameter BIN_LIB to the gmake command. gmake BIN_LIB=MY_IV_LIB By default the project will be built for the current release of the system. You can specify the target release version by passing the parameter TARGET_RLS to the gmake command. gmake TARGET_RLS=V7R3M0 No compile listing will be output to the console during the build. To get a compile listing you need to pass the parameter OUTPUT to the gmake command. gmake OUTPUT=*PRINT If the module and service program needs to be rebuilt you can pass the target ext (for building all external dependencies) and compile to the gmake command. gmake ext compile Single modules can be compiled by passing the module file name to the gmake command. gmake request.rpgmod For just building the service program execute the target ilevator.srvpgm. #iPKG But you don\u2019t need to build the service program by yourself. There is already a prepackaged version of ILEvator available at the iPKG RPM repository at https:\/\/repo.rpgnextgen.com. You just need to download the [iPKG client] and follow the instructions at https:\/\/repo.rpgnextgen.com. First create the library to you want to install ILEvator into. Just execute the install command for installing ILEvator. ipkg install ilevator This will install ILEvator in the default library IPKG. To specify another library just add the parameter IPKGLIB. ipkg install ilevator ipkglib(MY_IV_LIB) The copybooks can also be installed with iPKG. ipkg install 'ilevator-devel' The copybooks are packaged as stream files. By default the install command will try to install them in \/usr\/local\/include in the IFS. You can change the target location by passing the location as a parameter. ipkg install 'ilevator-devel' loc('\/home\/mihael\/include')","tags":"","url":"installation.html"},{"title":"Getting Started","text":"**FREE ctl-opt dftactgrp(*no) actgrp(*caller) bnddir('ILEVATOR') main(main); \/include 'ilevator.rpgle' dcl-proc main; dcl-s string varchar(IV_BUFFER_SIZE) ccsid(1208); string = iv_get('http:\/\/localhost'); iv_joblog(string); end-proc; This is probably the simplest use case you can implement with ILEvator. The content from the index page of the web server on localhost (your IBM i server) is fetched with a GET request and stored in the variable string which is output to the joblog. There is actually nothing to explain here as everything is clearly visible in the code. Depending on how you have installed ILEvator you need to adjust the compile command and\/or the code. If you have installed ILEvator manually by compiling the source you will have a binding directory ILEVATOR in your target library where the ILEvator service program has been placed. You just need to add the target library to your library list and are good to go. CRTBNDRPG SAMPLE INCDIR('\/my\/ilevator\/source\/directory\/headers') If you have installed ILEvator with iPKG you will find a binding directory IPKG in the library you installed the ILEvator package in. The ILEvator service program is automatically registered in that binding directory. So you will have to replace the value of the bnddir control option with IPKG. Now you just need to add the library you used with iPKG to your library list and are good to go. CRTBNDRPG SAMPLE INCDIR('\/my\/ipkg\/location\/for\/copybooks\/ilevator') #Hassle-free compile If you take the control\/compile options out of the source code it won\u2019t matter anymore how you installed your software packages or if you are using binding directories or not. Change the control options line to just: ctl-opt main(main); For every pro there is also a con: Now you have to do two build steps to create the program. CRTRPGMOD SAMPLE INCDIR('\/my\/directory\/for\/copybooks\/ilevator') CRTPGM SAMPLE DFTACTGRP(*NO) ACTGRP(*CALLER) BNDDIR('MY_BND_LIB\/BND_DIR') Even if you restructure your includes or binding directories or switch from\/to binding the service programs directly you don\u2019t have to change the source code anymore.","tags":"","url":"getting_started.html"},{"title":"Low-Level API vs Porcelain API","text":"ILEvator supports two kind of APIs: Low-Level API and Porcelain API. Depending on the features you need you will choose one over the other. #Low-Level API With the low-level API you can execute every HTTP request supported by ILEvator. You have the following workflow when using the low-level API. Create a new HTTP client instance with iv_newHttpClient Configure the HTTP client instance Execute the HTTP request with iv_execute Free allocated resources with iv_free #Porcelain API This API is rather high-level but is not as flexible as the low-level API. The API is modelled after the most used and obvious use cases. But some features cannot be used when using the porcelain API. All the HTTP methods supported by ILEvator have a porcelain API like iv_get, iv_options, iv_delete, etc. You have no access to the actual HTTP client instance. If you need to configure the HTTP client you have to use the low-level API. #HTTP Status Code There is also no direct querying of the returned HTTP status code. Every status code less than 400 is considered successful. When using the porcelain API every returned HTTP status code greater than or equal 400 sends an escape message to the caller. The escape message has the message id starting with ILV plus the HTTP status code. The HTTP status code 404 - Not Found will trigger an escape message with the message id ILV0404. If a HTTP status cannot be mapped to message id the escape message will have the message id ILV0999.","tags":"","url":"low_level_vs_porcelain.html"},{"title":"Consecutive Requests","text":"If you execute a HTTP request via the porcelain API or by calling iv_execute a socket to the web server is opened. The socket connection will automatically be closed after the request. In case you want to execute multiple requests to the same web server this will waste time and resources. #Unclosed Socket With ILEvator you also have the option to open a socket connection and leave it open for later requests by calling iv_connect. if (iv_connect(client : url)); executeRequests(); else; \/\/ could not connect to server ... endif; After having successfully opened a socket connection to the web server you can send HTTP requests by calling iv_http_request. This will not close the socket in contrast when using the other procedures like iv_execute. A call to iv_disconnect will close the socket connection. If you don\u2019t need the HTTP client instance any more you can skip calling iv_disconnect and just call iv_free. Any open socket connection of the passed HTTP client instance will be closed before freeing any memory. Note: On both calls (iv_connect and iv_http_request) a URL needs to be passed. iv_connect just needs the host and port part of the URL whereas iv_http_request needs the rest of the URL. You can safely just pass the same full URL to both procedures.","tags":"","url":"consecutive_requests.html"},{"title":"Forms","text":"#What is HTTP form data? Forms are sets of key\/value pairs. In the world wide web there is a specific way to encode forms: URL encoding (also known as percent encoding). Form data is most of the time transported in the message body. The form data is concated to a single string where the key\/value pairs are seperated by an ampersand (&amp;) character. Key and value are separated by an equal sign (=). \/\/ name: J\u00f6rg M\u00fcller \/\/ email: jmueller@example.com name=J%C3%B6rg%20M%C3%BCller&amp;email=jmueller%40example.com To indicate that the content of the HTTP message is form data the Content-Type header is set as application\/x-www-form-urlencoded. #Building Forms Forms are first class citizen in ILEvator. The procedures with the namespace (prefix) iv_forms can be used to easily build forms which can be used by the ILEvator HTTP client. dcl-ds formData likeds(iv_lvarpuchar_t); formData = iv_form_of( 'name' : 'J\u00f6rg M\u00fcller' : 'email' : 'jmueller@example.com' ); iv_form_free(formData); The data structure iv_lvarpuchar_t used for formData contains the value and the length. More or less it is a string with a dynamic length. But in contrast to the data type VARCHAR the memory is manually allocated and must also be freed with iv_form_free. Note: For your convenience the procedures iv_form_ofMap and iv_form_ofString has been overloaded with iv_form_of so that the system decides depending on the passed parameters which procedure will be executed. #Dynamic Form Content If you want to build up the content of the form dynamically or step by step you can build an empty or initialized list with the procedure iv_buildList and add entries with iv_addEntryToList. dcl-s list pointer; dcl-ds formData likeds(iv_lvarpuchar_t); list = iv_buildList(); iv_addEntryToList(list : 'name' : 'J\u00f6rg M\u00fcller'); iv_addEntryToList(list : 'email' : 'jmueller@example.com'); formData = iv_form_of(list); iv_form_free(formData); iv_freeList(list); Note: Don\u2019t forget to free the memory of the list with calling iv_freeList. #Sending Form Data Now we know how to build forms. ILEvator has a porcelain API for sending form data: iv_postForm. But if you need more control you can also use the low-level API iv_execute. The form data must be passed to the request buffer by calling iv_setRequestDataBuffer. dcl-s client pointer; dcl-ds formData likeds(iv_lvarpuchar_t); formData = iv_form_of( 'name' : 'J\u00f6rg M\u00fcller' : 'email' : 'jmueller@example.com' ); client = iv_newHttpClient(); iv_setRequestDataBuffer (client : formData.string : formData.length : IV_BYTES : IV_CCSID_BINARY); ... iv_form_free(formData); iv_free(client);","tags":"","url":"forms.html"},{"title":"Multipart","text":"#What is a HTTP multipart message? A normal HTTP message has exactly one part \u2026 the message body. Multipart refers to messages which have multiple parts. These parts reside all in the main message body. Each part consists of a header section and a body section. The parts are separated by a boundary. The encoding of the content of each part can either be text, binary or base64 encoded. Base64 encoded parts are often split into lines of 80 characters (including new line characters). For usage with the HTTP protocol this is not really necessary. But it helps when you need to inspect a multipart message content. Multipart messages are often used by file uploads but not exclusively. The most used MIME type for multipart messages when used with the HTTP protocol is multipart\/form-data. Though there are also other MIME types for multipart messages. #Building Multipart Messages The procedures with the namespace (prefix) iv_multipart can be used to easily build multipart messages. Sending multipart messages is done with the following steps: Create a new multipart \u201cobject\u201d Add parts to the multipart object Finalize the multipart object (no more parts can be added after this step) Registering the multipart object as a request handler at the HTTP client instance Executing the HTTP request Freeing the memory allocated by the multipart object The code for these steps can look like this: dcl-s multipart pointer; multipart = iv_multipart_new(IV_MULTIPART_MEDIA_TYPE); \/\/ step 1 iv_multipart_addPartFromString(multipart : 'user' : 'Mihael'); \/\/ step 2 iv_multipart_addPartFromFile(multipart : 'avatar' : 'avatar.jpg'); \/\/ step 2 iv_multipart_finalize(multipart); \/\/ step 3 httpClient = iv_newHttpClient(); iv_setRequestHandler(httpClient : multipart); \/\/ step 4 iv_execute(httpClient : 'POST' : 'http:\/\/localhost:35801\/upload'); \/\/ step 5 ... on-exit; iv_multipart_free(multipart); \/\/ step 6 Each multipart part has a name associated with it. In our case it is user and avatar. When a file is added as a part some extra attributes are also set on the HTTP header Content-Disposition, like filename. By default the filename of the original file is set on the Content-Disposition header. But a different filename can be passed to the procedure, see API documenation for iv_multipart_addPartFromFile. Note: The multipart message is assembled in a stream file in \/tmp. This can be viewed and analyzed for debugging purposes. iv_multipart_free deletes the file.","tags":"","url":"multipart.html"},{"title":"Headers","text":"ILEvator sets the minimal HTTP headers needed for the request. But you can add additional custom headers as needed. Headers can also be set multiple times. Generally the last one wins (though some headers are only allowed once like Host, Content-Length, Upgrade or Authorization). #Porcelain API When using the porcelain API like iv_get or iv_post you can add additional headers by passing a list of headers as a parameter to to procedure call. dcl-s headers pointer; headers = iv_buildList( 'accept-language' : 'dk,de;q=0.5' : 'authentication' : 'Bearer my_token' ); string = iv_get('http:\/\/localhost' : IV_MEDIA_TYPE_JSON : headers); The headers list is built dynamically and as such allocates memory dynamically. This memory must be freed manually by calling iv_freeList. iv_freeList(headers); #Low Level API The low level API supports setting HTTP headers global for that HTTP client instance. Those HTTP headers will be added to each HTTP request made with this client instance, see iv_addHeader and iv_addHeaders. dcl-proc main; dcl-s httpClient pointer; dcl-s buffer varchar(65000:4) ccsid(1208); dcl-s headers pointer; headers = iv_buildList( 'accept-language' : 'dk,de;q=0.5' : 'authentication' : 'Bearer my_token' ); httpClient = iv_newHttpClient(); iv_addHeaders(httpClient : headers); iv_setResponseDataBuffer(httpClient : %addr(buffer) : %size(buffer) : IV_VARCHAR4 : IV_CCSID_UTF8); iv_execute(httpClient : 'GET' : 'http:\/\/localhost'); if (iv_getStatus(httpClient) = IV_HTTP_OK); \/\/ everything ok else; \/\/ not ok endif; on-exit; iv_free(httpClient); iv_freeList(headers); end-proc; Headers can also be passed to the iv_execute procedure call. These headers will be appended after the headers previously set on the HTTP client instance. dcl-proc main; dcl-s httpClient pointer; dcl-s buffer varchar(65000:4) ccsid(1208); dcl-s headers pointer; headers = iv_buildList( 'accept-language' : 'dk,de;q=0.5' : 'authentication' : 'Bearer my_token' ); httpClient = iv_newHttpClient(); iv_setResponseDataBuffer(httpClient : %addr(buffer) : %size(buffer) : IV_VARCHAR4 : IV_CCSID_UTF8); iv_execute(httpClient : 'GET' : 'http:\/\/localhost' : headers); if (iv_getStatus(httpClient) = IV_HTTP_OK); \/\/ everything ok else; \/\/ not ok endif; on-exit; iv_free(httpClient); iv_freeList(headers); end-proc; Note: The headers list is built dynamically and as such allocates memory dynamically. This memory must be freed manually by calling iv_freeList. #Dynamic Header List The list can be created with iv_buildList. You can create an empty list or fill the list with initial values. The list is not immutable. You can add values to the list by calling iv_addHeaderToList. dcl-s headers pointer; headers = iv_buildList(); iv_addHeaderToList(headers : 'accept-language' : 'dk,de;q=0.5'); iv_addHeaderToList(headers : 'authentication' : 'Bearer my_token'); string = iv_get('http:\/\/localhost' : IV_MEDIA_TYPE_JSON : headers); iv_freeList(headers); end-proc; #Request Handler You can also hook yourself into the flow of a request and modify the request, f. e. add a header. This can be done with a request handler. The handler is implemented as a data structure with a subfield processRequest which contains the pointer to the function which will be called by ILEvator to intercept and process the request. dcl-ds requestHandler_t qualified template; processRequest pointer(*proc); end-ds; The process procedure has a predefined procedure interface which needs to be implemented. dcl-pi *n; handler pointer value; request pointer value; end-pi; So a procedure to add a header could look like this: dcl-proc addCustomHeader export; dcl-pi *n; handler pointer value; request pointer value; end-pi; dcl-ds requestHandler likeds(requestHandler_t) based(handler); iv_request_addHeader(request : 'X-Custom-Header' : 'Value 123'); end-proc; Inside the process procedure you can use the request API of ILEvator to modify the request before it is sent to the server. Last but not least you need to set the pointer to your process procedure in the handler data structure. dcl-ds requestHandler likeds(requestHandler_t) inz; requestHandler.processRequest = %paddr(addCustomHeader); And before you are making your first call you need to register the request handler at the HTTP client instance. iv_setRequestHandler(httpClient : %addr(requestHandler)); Now on each request addCustomHeader will be called and each request will have the HTTP header X-Custom-Header. #Non-ASCII Characters Historically characters from the ISO-8859-1 character set were also allowed in HTTP header values but that is a thing of the past. Servers, frameworks and software libraries will expect only ASCII characters in HTTP header keys and values. So as a general rule only ASCII characters should be used. In case non-ASCII characters need to be passed as a header value the sender and the receiver will have to encode\/decode them manually. Base64 and MIME encoding can be used for these cases. ILEvator provides procedures for both, iv_encode_mime and iv_encode_base64 \/ iv_encode_base64_buffer.","tags":"","url":"headers.html"},{"title":"Encoding","text":"Encoding plays an important role in the world wide web as we no longer are only on our own server but are communicating with different servers which may be using the same or a different encoding as we are. #MIME Types MIME stands for Multipurpose Internet Mail Extensions and was originally designed and developed for email communication (mainly SMTP) but has also founds its way into other communication protocols like HTTP. In the context of HTTP the MIME type indicates what the format and structure of the message body is. But in case of vendor or personal specific MIME types it can also give you more detailed information about the message body. Note: The terms media type and MIME type are (mostly) interchangeable in the context of HTTP. #Examples text\/plain : This is just text and by default the characters set used is US-ASCII. application\/xml : This is XML and the encoding is specified in the XML itself. application\/json : This is JSON. JSON by default is encoded in UTF-8. application\/vnd.rpgnextgen.blog : The content is a blog entry from RPG Next Gen. But we have no idea what the format is like or the encoding. application\/prs.rpgnextgen.blog+json : This is better as we now know what is passed as the message body and in what format. application\/prs.rpgnextgen.blog+json+v1 : This defines the content of the message pretty well. It is a blog entry from RPG Next Gen in the JSON format and the structure of the JSON is in version 1. Depending on the content and the MIME type it might be necessary to state the encoding of the content. text\/plain; charset=UTF-8 : In this case the text is not in US-ASCII but in UTF-8 and may contain symbols not available in US-ASCII. #Content Type If data is sent to the server (f. e. on POST, PUT, PATCH requests) the HTTP header Content-Type should be set accordingly. HTTP headers can be set for all requests made by the HTTP client by using iv_addHeader and iv_addHeaders. If a HTTP header should only be used in a single request then a list of headers can be passed as an additional parameter. The porcelain API provides a separate parameter for passing the Content-Type HTTP header value. The Content-Type HTTP header only declares what the content is expected to be. It doesn\u2019t not acutally converts any data to the corresponding MIME type or changes the data to the declared encoding\/charset. It acts like a label on a packages. It states what to expect inside the package but the real content may differ from the label. #Message Body Data Translation When using iv_execute the data is provided by passing the variable to iv_setRequestDataBuffer and specifying the CCSID on the last parameter. The data will automatically be converted to the CCSID which corresponds to the Content-Type used on the request. If no CCSID could be mapped to the used Content-Type the data will be converted to UTF-8. The porcelain API only accepts data in UTF-8. When receiving data the data is put into the variable provided by calling iv_setResponseDataBuffer. Currently there is no extra translation of the data. The data from the message response is put into the data buffer as is.","tags":"","url":"encoding.html"},{"title":"Request Handler","text":"The building of the request takes several steps. Some steps are done internally by ILEvator but at some point you can hook into the build process and modify the request as you need it, f. e. adding a custom HTTP header. If global HTTP headers are set on the HTTP client instance they will be added first. The HTTP headers which have been passed for this request will be append behind the global headers. The HTTP protocol states that the last one wins (in most cases, there are some exceptions). So a HTTP header for this request will overwrite the global header. #Authentication Provider With iv_setAuthProvider a request handler can be registered at the client. The authentication provider needs to be provided as a pointer to a data structure. The data structure needs to have a procedure pointer as its first subfield. dcl-ds iv_auth_t qualified template; processRequest pointer(*proc); end-ds; As the authentication provider is passed as a pointer to the ILEvatotr procedure the data structure can have as many subfields as you need. It is just important that the first subfield is the procedure pointer to the procedure which will be called by ILEvator. Take a look at the Basic Auth provider which comes with the ILEvator project. The procedure which will be called by ILEvator needs to implement a specific procedure interface. dcl-pi *n; authProvider pointer value; request pointer value; end-pi; The first parameter authProvider is a pointer to your data structure. So you have access to all the data you put into your data structure in the first place. dcl-ds myAuthProvider likeds(my_auth_provider_t) based(authProvider); #Request Handler After executing the authentication handler procedure the request handler is called by ILEvator if one has been registered. The request handler can be registered with calling iv_setRequestHandler. The request handler has the same concept and interface as the authentication provider. After the request handler has been called the request object will be serialized and sent to the server.","tags":"","url":"request_handler.html"},{"title":"HTTPS","text":"To be able to make HTTP requests over SSL\/TLS (also known as HTTPS) you first need to set the keystore with the necessary certificates by calling iv_setCertificate. If the keystore needs a password it also needs to be passed to the procedure. The keystore can also be registered by using environment variables. ILEVATOR_CERTIFICATE : path to the keystore file ILEVATOR_CERTIFICATE_PASSWORD : password The ILEvator project comes with a keystore file ilevator.kdb. #SSL\/TLS Version By default ILEvator and the target server will try to negotiate the newest\/highest SSL\/TLS version supported by both parties. ILEvator allows to disabled specific SSL\/TLS versions. This can either be made by a procedure call or by setting an environment variable. Environment variables take precedence over settings made by procedure calls. #Configure TLS Version Calling iv_configureTlsVersion will enable or disable the TLS version for negotiation with the server. A constant is available for each TLS version like IV_TLS_13 for TLS version 1.3. iv_configureTlsVersion(httpClient : IV_TLS_13 : *off); This setting will only affect the HTTP client instance you passed as the first parameter. Multiple client instances can be created side by side with different TLS version settings. #Configure SSL Version ILEvator also supports configuring SSL 3 for HTTPS communication. iv_configureSslVersion(httpClient : IV_SSL_3 : *on); This setting will only affect the HTTP client instance you passed as the first parameter. Multiple client instances can be created side by side with different SSL version settings. #Environment Variable Each SSL\/TLS version can also be enabled\/disabled with the setting of an environment variable. TLS 1.0 : ILEVATOR_TLS_10 TLS 1.1 : ILEVATOR_TLS_11 TLS 1.2 : ILEVATOR_TLS_12 TLS 1.3 : ILEVATOR_TLS_13 SSL 3 : ILEVATOR_SSL_3 Setting the value of the environment variable to 0 disables the TLS version and 1 enables the TLS version. Disable TLS version 1.1: ADDENVVAR ILEVATOR_TLS_11 '0' Enable TLS version 1.3: ADDENVVAR ILEVATOR_TLS_13 '1' Note: Setting the SSL\/TLS version via environment variables affects all HTTP client instances in the job. #Keystore File ILEvator uses the IBM GSKit on the IBM i server for making a secure connection to the target server. A keystore file in the GSKit format is needed with the certificates corresponding to the target server. To create the keystore file (suffix .kdb) the command gsk8cmd from the IBM GSKit can be used.","tags":"","url":"https.html"},{"title":"HTTP Tunneling","text":"Tunneling transmits private network data and protocol information through public network by encapsulating the data. HTTP tunneling is using a protocol of higher level (HTTP) to transport a lower level protocol (TCP). \u2014 MDN Web Docs ILEvator supports HTTP tunneling. The HTTP client instance just needs to have the proxy URL set. Any further calls with this HTTP client instance will be made through the proxy. \/\/ configure HTTP client instance to use proxy iv_setProxyTunnel(httpClient : 'http:\/\/my_proxy:3128'); The porcelain API cannot be used when using HTTP tunneling as the HTTP client instance needs to be configured and that cannot be done with the procelain API. For executing HTTP requests always use iv_execute. dcl-proc main; dcl-s httpClient pointer; dcl-s buffer varchar(65000:4) ccsid(1208); httpClient = iv_newHttpClient(); iv_setProxyTunnel (httpClient : 'http:\/\/my_proxy:3128'); iv_setResponseDataBuffer( httpClient : %addr(buffer) : %size(buffer) : IV_VARCHAR4 : IV_CCSID_UTF8 ); iv_execute (httpClient : 'GET' : 'http:\/\/target_resource'); if (iv_getStatus(httpClient) &lt;&gt; IV_HTTP_OK); iv_joblog('Invalid status: ' + %char(iv_getStatus(httpClient))); endif; iv_joblog(%char(buffer)); on-exit; iv_free(httpClient); end-proc;","tags":"","url":"http_tunneling.html"},{"title":"WebSocket","text":"In a nutshell, WebSocket is a technology that enables bidirectional, full-duplex communication between client and server over a persistent, single-socket connection. The intent is to provide what is essentially an as-close-to-raw-as-possible TCP communication layer to web application developers while adding a few abstractions to eliminate certain friction that would otherwise exist concerning the way the web works. A WebSocket connection starts as an HTTP request\/response handshake; beyond this handshake, WebSocket and HTTP are fundamentally different. \u2014 websocket.org ILEvator supports the WebSocket protocol as a first class citizen. Procedures, variables and constants with the prefix iv_ws are part of the WebSocket support. A WebSocket connection is initiated by doing a \u201chandshake\u201d which is a normal HTTP request with some corresponding HTTP headers to perform an \u201cUpgrade\u201d. From then on the WebSocket protocol is in effect. WebSocket is fundamentally different from HTTP. For a compact comparison of these two protocols visit WebSocket.org. This statement from WebSocket.org sums it up quite nicely: The intent is to provide what is essentially an as-close-to-raw-as-possible TCP communication layer \u2026 #Usage First you need to create a new HTTP client instance and make a connect (Upgrade request) to the websocket server. dcl-s client pointer; client = iv_newHttpClient(); if (iv_ws_connect(client : 'ws:\/\/localhost:35801\/echo')); \/\/ got a connection to the web socket server -&gt; feel free ;-) endif; Some websocket servers are very picky and may deny a connection. ILEvator will output the reason to the job log when the debug mode has been enabled. After you got a connection to the websocket server you can send and receive messages. Remember that WebSocket is a bi-directional protocol. You don\u2019t have to make a request to get data from the server. The server can send data to the client without the client making the first move (server push). If you are finished you need to close the connection by calling iv_ws_disconnect. This will close the socket connection and you can reuse the client instance. Note: The socket connection will be closed automatically when releasing all resources on calling iv_free. #Imperative Style ILEvator lets you be in full control when it comes to communicating with the websocket server. You decide when you want to receive messages and when you send messages. dcl-s client pointer; dcl-ds response likeds(iv_ws_message_t) inz; dcl-s msg char(50); client = iv_newHttpClient(); if (iv_ws_connect(client : 'ws:\/\/localhost:35801\/echo')); iv_ws_sendText(client : 'Hello World!'); response = iv_ws_receiveText(client); msg = %char(response.payload); dsply msg; else; dsply 'Connection failed.'; endif; on-exit; iv_free(client); This style is best used when you (mainly) want to send data to the websocket server. #Reactive Style When your main goal is to react on messages sent from a websocket server you can more easily achieve this by using a more reactive style. You just provide a procedure which gets called every time the websocket server sends messages to your client. ILEvator supports this with the procedures iv_ws_onMessageand iv_ws_endMessageReceiving. Your procedure needs to implement the following procedure interface: dcl-pi *n; client pointer value; userData pointer value; message likeds(iv_ws_message_t); end-pi; client : This is your HTTP client instance. If you want to respond to the received message you will need this pointer. userData : userData points to data you provided on the iv_ws_onMessage call. By passing this to your procedure you don\u2019t need to have some static variables for data your procedure needs to access. message : This is the message received from the websocket server. Note: Control frames (messages) will be processed by ILEvator and will not be passed to your callback procedure. This example will count the number of text messages sent from the server till the server disconnects. dcl-proc main; dcl-s client pointer; dcl-s errorMessage varchar(256); dcl-s userData int(10); client = iv_newHttpClient(); iv_ws_connect(client : 'ws:\/\/localhost:35801\/ws'); iv_ws_onMessage(client : %paddr(callback) : %addr(userData)); dsply %trimr('Message count: ' + %char(userData)); on-exit; iv_free(client); end-proc; dcl-proc callback; dcl-pi *n; client pointer value; userData pointer value; message likeds(iv_ws_message_t); end-pi; dcl-s counter int(10) based(userData); dcl-s msg char(50); if (message.opcode = IV_WS_OPCODE_DATA_TEXT); counter += 1; msg = %char(message.payload); dsply msg; endif; end-proc; #Tests The ILEvator project contains an integration test server which also integrates a web socket server, Eclipse Tyrus. This test server can be run on IBM i, see Readme.md. The test suite ITWEBSOCK contains all the test cases which can be easily run with RPGUnit by a Jenkins instance on IBM i. #Use Cases The WebSocket protocol is mostly used in the web environment to communicate streaming data between the browser and the server. But there are some cases where you want to stream data from a backend process to the server or receive streaming data from the server. Message streaming server which support the WebSocket protocol are Apache Kafka Apache Pulsar Another use case is where ports in an environment are restricted to HTTP(S) but an application specific protocol (not HTTP) over sockets is needed.","tags":"","url":"websocket.html"},{"title":"Debug Mode","text":"ILEvator supports writing debug messages into the job log. These messages are of type *INFO. To activate debug messages the environment variable ILEVATOR_DEBUG needs to be set to 1 which maps to *ON. By default this is turned off. ADDENVVAR ILEVATOR_DEBUG '1' The environment variable needs to be set before the first call of any procedure from the service program ILEVATOR (more precisely before activating the service program). Once set it cannot be unset. If you need to set\/unset this on a regular basis then you can run it in a named activation group. If you want to unset the debug mode just reclaim the activation group so that the service program will be loaded again on the next call and evaluates the environment variable for the debug mode again. #Communication Trace The communication between the client and the server can be traced separatedly from the debug information in a stream file. Tracing is enabled by calling the procedure iv_setCommTrace and passing the stream file for the trace as a parameter or by setting the environment variable ILEVATOR_TRACE_STMF to the stream file for the trace. This needs to be set before the first HTTP request with the created client. ADDENVVAR ILEVATOR_TRACE_STMF '\/home\/my_user\/trace_file.txt' The file will be created if it does not exist (with the CCSID Latin 1 , 5348 = Windows, Latin 1 with Euro, see CCSID values defined on IBM i). The trace data will be appended to the configured trace file.","tags":"","url":"debug_mode.html"},{"title":"Examples","text":"Here is a short list of examples provided by the project. You can find the examples in the Git repository. Simple GET request HTTPS Get request Simple GET request with encoded query parameters Simple GET request with HTTP status handling Simple GET request with additional headers Simple POST request qith text as message body Simple POST request with non default content type header Write response data to stream file Enable debug output Enable comm trace output to stream file GET request with basic auth GET request with bearer token Set automatic retries Simple POST request with form data POST request with different charset POST request with multipart form data Tunneling HTTP through a proxy (HTTP tunneling) Tunneling HTTPS through a proxy (HTTP tunneling) Sending SMS with LINK Mobility GET request to Float Rates Specifying TLS version HTTPS GET request to VAX 360 SNI - Server Name Indication HTTP request with blocking sockets Consecutive HTTP requests","tags":"","url":"examples.html"},{"title":"Frequently Asked Questions","text":"#What does Porcelain API mean? Porcelain API is a more user-friendly API which handles all the more low-level API of ILEvator. \u201cPorcelain\u201d is the material from which toilets are usually made (and sometimes other fixtures such as washbasins). This is distinct from \u201cplumbing\u201d (the actual pipes and drains), where the porcelain provides a more user-friendly interface to the plumbing. \u2014 StackOverflow","tags":"","url":"faq.html"}]});